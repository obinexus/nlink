#!/usr/bin/env python3

import os
import sys
import re
from pathlib import Path

# Define dependency map based on architectural specifications
DEPENDENCY_MAP = {
    "pipeline": ["minimizer", "symbols"],
    "mpsystem": ["common", "pipeline"],
    "spsystem": ["common", "pipeline"],
    "pattern_matching": ["pattern", "common"],
    "metadata": ["common"],
    "minimizer": ["common"],
    "symbols": ["common"],
    "versioning": ["common"],
    "parser": ["common", "tokenizer"],
    "tokenizer": ["common", "token_type", "token_value"],
    "type": ["common"],
    "tactic": ["common"],
    "tatit": ["common"],
    "token_type": ["common"],
    "token_value": ["common"],
    "schema": ["common"],
    "config": ["common"],
}

# Template for component build CMakeLists.txt
CMAKELISTS_TEMPLATE = '''# {component}_build/CMakeLists.txt
# Generated by OBINexus Component Integration System
cmake_minimum_required(VERSION 3.16)

# Component integration with build orchestration
project({component}_build VERSION 1.0.0 LANGUAGES C)

# Import build system utilities
include(${{CMAKE_SOURCE_DIR}}/cmake/ComponentSystem.cmake)

# Define component sources
file(GLOB_RECURSE COMPONENT_SOURCES 
     "${{CMAKE_SOURCE_DIR}}/src/core/{component}/*.c"
     "${{CMAKE_SOURCE_DIR}}/src/core/{component}/*.h")

# Define component dependencies
set(COMPONENT_DEPENDENCIES "{dependencies}")

# Register component with build system
nlink_register_component(
    NAME {component}
    SOURCES ${{COMPONENT_SOURCES}}
    DEPENDENCIES ${{COMPONENT_DEPENDENCIES}}
    ENABLE_STATIC TRUE
    ENABLE_SHARED FALSE
)

# Verification layer
add_custom_target({component}_verification
    COMMAND ${{CMAKE_COMMAND}} -E echo "Component integrity verified: {component}"
)
add_dependencies({component} {component}_verification)
'''

def generate_component_build_files(src_core_dir):
    """Generate CMakeLists.txt files for all component build directories"""
    component_dirs = [d for d in os.listdir(src_core_dir) 
                     if os.path.isdir(os.path.join(src_core_dir, d))]
    
    for component in component_dirs:
        # Skip directories that end with _build
        if component.endswith('_build'):
            continue
            
        build_dir = os.path.join(src_core_dir, f"{component}_build")
        
        # Create build directory if it doesn't exist
        os.makedirs(build_dir, exist_ok=True)
        
        # Get dependencies for this component
        dependencies = DEPENDENCY_MAP.get(component, [])
        dependencies_str = " ".join(dependencies)
        
        # Generate CMakeLists.txt content
        cmakelists_content = CMAKELISTS_TEMPLATE.format(
            component=component,
            dependencies=dependencies_str
        )
        
        # Write CMakeLists.txt file
        cmakelists_path = os.path.join(build_dir, "CMakeLists.txt")
        with open(cmakelists_path, "w") as f:
            f.write(cmakelists_content)
        
        print(f"Generated {cmakelists_path}")

def fix_build_system_path(build_system_path):
    """Fix incorrect path in BuildSystem.cmake"""
    if not os.path.exists(build_system_path):
        print(f"ERROR: {build_system_path} not found")
        return False
        
    with open(build_system_path, 'r') as f:
        content = f.read()
    
    # Fix incorrect path reference
    fixed_content = re.sub(
        r'include\(\$\{CMAKE_CURRENT_LIST_DIR\}/cmake/ExecutableConfig\.cmake\)',
        r'include(${CMAKE_CURRENT_LIST_DIR}/ExecutableConfig.cmake)',
        content
    )
    
    if content != fixed_content:
        with open(build_system_path, 'w') as f:
            f.write(fixed_content)
        print(f"Fixed path in {build_system_path}")
        return True
    
    return False

def fix_duplicate_targets(core_cmakelists_path):
    """Fix duplicate targets in core/CMakeLists.txt"""
    if not os.path.exists(core_cmakelists_path):
        print(f"ERROR: {core_cmakelists_path} not found")
        return False
        
    with open(core_cmakelists_path, 'r') as f:
        content = f.read()
    
    # Remove duplicate target definition
    lines = content.splitlines()
    seen_targets = set()
    result_lines = []
    
    skip_section = False
    for line in lines:
        if "add_custom_target(nlink_unified_core" in line:
            if "nlink_unified_core" in seen_targets:
                skip_section = True
            else:
                seen_targets.add("nlink_unified_core")
                skip_section = False
                result_lines.append(line)
        elif skip_section and "endif()" in line:
            skip_section = False
        elif not skip_section:
            result_lines.append(line)
    
    fixed_content = "\n".join(result_lines)
    
    if content != fixed_content:
        with open(core_cmakelists_path, 'w') as f:
            f.write(fixed_content)
        print(f"Fixed duplicate targets in {core_cmakelists_path}")
        return True
    
    return False

if __name__ == "__main__":
    # Detect project root
    project_root = os.getcwd()
    if not os.path.exists(os.path.join(project_root, "src", "core")):
        print("ERROR: Must run from project root directory")
        sys.exit(1)
    
    # Generate component build files
    src_core_dir = os.path.join(project_root, "src", "core")
    generate_component_build_files(src_core_dir)
    
    # Fix BuildSystem.cmake path
    build_system_path = os.path.join(project_root, "cmake", "BuildSystem.cmake")
    fix_build_system_path(build_system_path)
    
    # Fix duplicate targets
    core_cmakelists_path = os.path.join(project_root, "src", "core", "CMakeLists.txt")
    fix_duplicate_targets(core_cmakelists_path)
    
    print("System integration complete. Run 'make -j$(nproc)' to rebuild")
